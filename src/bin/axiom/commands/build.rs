use std::os::unix::fs::PermissionsExt;

use anyhow::Context;
use colored::Colorize;
use std::io::Write;

#[derive(clap::Args)]
pub struct Build {
    /// Accept the Minecraft EULA (End User License Agreement) without prompting for user input.
    #[arg(long, short = 'y')]
    pub(crate) accept_eula: bool,
}

impl crate::commands::Run for Build {
    fn run(&self, ctx: &mut crate::context::Context) -> Result<(), crate::error::Error> {
        let package = ctx
            .package()
            .with_context(|| "failed to get package manifest")?;

        let server = package.server();
        std::fs::create_dir_all(server.path())
            .with_context(|| "failed to create 'server' directory")?;

        // Don't attempt to get a new server JAR if the version/build hasn't been changed.
        for _ in 0..1 {
            let version = package.manifest().server().version();
            let build = package.manifest().server().build();

            match server.build_info() {
                Ok(build_info) => {
                    if (version, build) == (build_info.version(), build_info.build()) {
                        break;
                    }
                }
                Err(err) => {
                    // This warning doesn't make sense if this is the first time the server is
                    // being built. Check for other server files to ensure this warning is only
                    // shown if the `server.jar` was truly expected to exist.
                    if server.server_properties().exists() {
                        tracing::warn!(
                            "failed to get build information for current server JAR: {err}"
                        )
                    }
                }
            }

            tracing::info!("downloading the latest build");
            super::update::Update::run(
                &super::update::Update {
                    version: Some(version.to_owned()),
                    build: Some(build),
                    allow_experimental: true,
                    allow_downgrade: true,
                    timeout: 120,
                },
                ctx,
            )?
        }

        // The `server.properties` file is generated by the server on the first run.
        // The absence of this file indicates we need to run the server to generate the initial files.
        if !server.server_properties().exists() {
            tracing::info!("generating server files");
            let server_jar = server.server_jar();
            assert!(server_jar.exists());

            _ = std::process::Command::new("java")
                .args([
                    "-jar",
                    server_jar
                        .to_str()
                        .expect("expected path to be valid unicode"),
                    "--initSettings",
                ])
                .current_dir(server.path())
                .stdout(std::process::Stdio::null())
                .stderr(std::process::Stdio::null())
                .status()
                .with_context(|| "failed to execute command 'java'")?;
        }

        if let Some(properties) = package.manifest().properties() {
            // Overwrite `server.properties` with the properties in the config file. Any missing
            // keys should be generated automatically by the server on the next run.
            let path = server.server_properties();
            let contents = properties.to_server_properties();
            std::fs::write(path, contents).with_context(|| "failed to update server.properties")?;
        }

        for _ in 0..1 {
            match package.server().has_accepted_eula() {
                Ok(true) => break,
                Ok(false) => {}
                Err(err) => tracing::warn!("failed to read the `eula.txt` file: {err}"),
            }

            if !self.accept_eula && !prompt_user_to_accept_eula() {
                // User was prompted to accept the EULA interactively but they declined.
                return Ok(());
            }

            std::fs::write(server.eula_txt(), "eula=true")
                .with_context(|| "failed to write to eula.txt")?;
        }

        tracing::info!("generating the start script");
        let memory = package
            .manifest()
            .launcher()
            .and_then(|launcher| launcher.memory())
            .unwrap_or("4096M");

        let mut preset = package
            .manifest()
            .launcher()
            .map(|launcher| launcher.preset())
            .unwrap_or(&axiom::manifest::Preset::None)
            .flags()
            .join(" ");

        if !preset.is_empty() {
            preset += " ";
        }

        let jvm_args = package
            .manifest()
            .launcher()
            .and_then(|launcher| launcher.jvm_args())
            .unwrap_or_default()
            .join(" ");

        let game_args = package
            .manifest()
            .launcher()
            .and_then(|launcher| launcher.game_args())
            .unwrap_or_default()
            .join(" ");

        assert!(preset.is_empty() || preset.ends_with(" "));
        let contents = format!(
            "#!/usr/bin/bash\n\
            \n\
            java -Xms{memory} -Xmx{memory} {preset}{jvm_args} -jar ./server.jar {game_args}"
        );

        std::fs::write(server.start_sh(), contents)
            .with_context(|| "failed to write to start.sh")?;

        tracing::info!("making the start script executable");
        let metadata = package
            .server()
            .start_sh()
            .metadata()
            .with_context(|| "failed to get start.sh metadata")?;

        let permissions = metadata.permissions();
        // Give the user permission to execute the file, while leaving all other permissions
        // untouched. This is effectively the same as running `chmod u+x` on the file.
        let mode = permissions.mode() | 0o700;
        std::fs::set_permissions(server.start_sh(), std::fs::Permissions::from_mode(mode))
            .with_context(|| "failed to make the start script executable")?;

        let mut stderr = std::io::stderr().lock();
        writeln!(stderr, "âœ… the Minecraft server is ready!").ok();

        Ok(())
    }
}

/// Prompts the user to interactively accept the Minecraft EULA.
fn prompt_user_to_accept_eula() -> bool {
    println!(
        "{}: {}",
        "You must accept the Minecraft EULA before continuing".bold(),
        "https://aka.ms/MinecraftEULA".underline().cyan()
    );
    print!("{} {} (y/N): ", "*".cyan(), "Accept and continue?".bold());
    #[rustfmt::skip]
    std::io::stdout().flush().expect("failed to print full prompt");

    let mut input = String::new();
    std::io::stdin()
        .read_line(&mut input)
        .expect("failed to read from stdin");

    input.trim().to_lowercase() == "y"
}
